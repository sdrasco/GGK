function Z=CartesianWorldline_Spherical(X)
%
% Z=CartesianWorldline_Spherical(X)
%
% Computes cartesian components of the world line by assuming that 
% Boyer-Lindquist coordinates are spherical flat space coordinates. 
% The input worldline structure X must be produced by KludgedXofl.
%
% Output structure has fields:
%
%       Z.x = X.r sin(X.theta) cos(X.phi)
%      Z.dx = d/dt(Z.x)
%     Z.ddx = d/dt(d/dt(Z.x))
%    Z.dddx = d/dt(d/dt(d/dt(Z.x)))
%       Z.y = X.r sin(X.theta) sin(X.phi)
%      Z.dy = d/dt(Z.y)
%     Z.ddy = d/dt(d/dtZ.y))
%    Z.dddy = d/dt(d/dt(d/dt(Z.y)))
%       Z.z = X.r cos(X.theta)
%      Z.dz = d/dt(Z.z)
%     Z.ddz = d/dt(d/dt(Z.z))
%    Z.dddz = d/dt(d/dt(d/dt(Z.z)))
%
% See also CARTESIANWORLDLINE_SPHEROIDAL KLUDGEDXOFL HPHX
%
% Steve Drasco
%

% compute cartesian coordinates
sintheta = sin(X.theta);
costheta = cos(X.theta);
sinphi = sin(X.phi);
cosphi = cos(X.phi);
x = X.r .* sintheta .* cosphi;
y = X.r .* sintheta .* sinphi;
z = X.r .* costheta;

% compute first derivatives (parentheses for guidence)
dx = (X.dr .* x ./ X.r) + (X.dtheta .* z .* cosphi) - (X.dphi .* y);
dy = (X.dr .* y ./ X.r) + (X.dtheta .* z .* sinphi) + (X.dphi .* x); 
dz = (X.dr .* costheta) - (X.dtheta .* X.r .* sintheta);

% compute second derivatives (parentheses for guidence)
ddx = (X.ddr .* x ./ X.r) - (X.dr.^2 .* x ./ (X.r.^2)) + (X.dr .* dx ./ X.r) ...
    + (X.ddtheta .* z .* cosphi) + (X.dtheta .* dz .* cosphi) ...
    - (X.dphi .* X.dtheta .* z .* sinphi) - (X.ddphi .* y) - (X.dphi .* dy);
ddy = (X.ddr .* y ./ X.r) - (X.dr.^2 .* y ./ (X.r.^2)) + (X.dr .* dy ./ X.r) ...
    + (X.ddtheta .* z .* sinphi) + (X.dtheta .* dz .* sinphi) ...
    + (X.dtheta .* X.dphi .* z .* cosphi) + (X.ddphi .* x) + (X.dphi .* dx);
ddz = (X.ddr .* costheta) - 2*(X.dtheta .* X.dr .* sintheta) ...
    - (X.ddtheta .* X.r .* sintheta) - (X.dtheta.^2 .* z);

% compute third derivatives (parentheses for guidence)
dddx = (X.dddr .* x ./ X.r) ...
    - 3 * X.dr .* X.ddr .* x ./ (X.r.^2) ...
    + 2 * X.ddr .* dx ./ X.r ...
    + 2 * X.dr.^3 .* x ./ (X.r.^3) ...
    - 2 * X.dr.^2 .* dx ./ (X.r.^2) ...
    + X.dr .* ddx ./ X.r ...
    + X.dddtheta .* z .* cosphi ...
    + 2 * X.ddtheta .* dz .* cosphi ...
    - 2 * X.dphi .* X.ddtheta .* z .* sinphi ...
    + X.dtheta .* ddz .* cosphi ...
    - 2 * X.dphi .* X.dtheta .* dz .* sinphi ...
    - X.ddphi .* X.dtheta .* z .* sinphi ...
    - X.dphi.^2 .* X.dtheta .* z .* cosphi ...
    - X.dddphi .* y ...
    - 2 * X.ddphi .* dy ...
    - X.dphi .* ddy;
dddy = (X.dddr .* y ./ X.r) - (3 * X.ddr .* X.dr .* y ./ (X.r.^2)) ...
    + (2 * X.ddr .* dy ./ X.r) + (2 * X.dr.^3 .* y ./ (X.r.^3)) ...
    - (2 * X.dr.^2 .* dy ./ (X.r.^2)) + (X.dr .* ddy ./ X.r) ...
    + (X.dddtheta .* z .* sinphi) + (2 * X.ddtheta .* dz .* sinphi) ...
    + (2 * X.dphi .* X.ddtheta .* z .* cosphi) ...
    + (X.dtheta .* ddz .* sinphi) ...
    + (2 * X.dphi .* X.dtheta .* dz .* cosphi) ...
    + (X.ddphi .* X.dtheta .* z .* cosphi) ...
    - (X.dphi.^2 .* X.dtheta .* z .* sinphi) ...
    + (X.dddphi .* x) + (2 * X.ddphi .* dx) + (X.dphi .* ddx);
dddz = (X.dddr .* costheta) - (3 * X.dtheta .* X.ddr .* sintheta) ...
    - (3 * X.ddtheta .* X.dr .* sintheta) ...
    - (2 * X.dtheta.^2 .* X.dr .* costheta) ...
    - (X.dddtheta .* X.r .* sintheta) ...
    - (3 * X.dtheta .* X.ddtheta .* z) - (X.dtheta.^2 .* dz);

% fill the output structure (clearing memory as we go, since these are big)
clear costheta sintheta cosphi sinphi;
Z.x = x; clear x;
Z.dx = dx; clear dx;
Z.ddx = ddx; clear ddx;
Z.dddx = dddx; clear dddx;
Z.y = y; clear y;
Z.dy = dy; clear dy;
Z.ddy = ddy; clear ddy;
Z.dddy = dddy; clear dddy;
Z.z = z; clear z;
Z.dz = dz; clear dz;
Z.ddz = ddz; clear ddz;
Z.dddz = dddz; clear dddz;