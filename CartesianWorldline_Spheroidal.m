function Z=CartesianWorldline_Spheroidal(X,a)
%
% Z=CartesianWorldline_Spheroidal(X,a)
%
% Computes cartesian components of the world line by assuming that 
% Boyer-Lindquist coordinates are spheroidal flat space coordinates. 
% The input worldline structure X must be produced by KludgedXofl.
%
% Output structure has fields:
%
%    Z.x = rho sin(X.theta) cos(X.phi)
%      Z.dx = d/dlambda(Z.x)
%     Z.ddx = d/dlambda(d/dlambda(Z.x))
%    Z.dddx = d/dlambda(d/dlambda(d/dlambda(Z.x)))
%       Z.y = rho sin(X.theta) sin(X.phi)
%      Z.dy = d/dlambda(Z.y)
%     Z.ddy = d/dlambda(d/dlambda(Z.y))
%    Z.dddy = d/dlambda(d/dlambda(d/dlambda(Z.y)))
%       Z.z = X.r cos(X.theta)
%      Z.dz = d/dlambda(Z.z)
%     Z.ddz = d/dlambda(d/dlambda(Z.z))
%    Z.dddz = d/dlambda(d/dlambda(d/dlambda(Z.z)))
%
% where who = sqrt(X.r.^2 + a^2) where a is the dimmensionless Kerr spin 
% parameter [0 1).  Note that only x and y differ from those computed in 
% the spherical approximation.
%
% See also CARTESIANWORLDLINE_SPHERICAL KLUDGEDXOFL HPHX
%
% Steve Drasco
%

% first compute rho and its three lambda-derivatives
   rho = sqrt(X.r.^2 + a^2);
  drho = X.r .* X.dr ./ rho;
 ddrho = (X.dr.^2 ./ rho) + (X.r .* X.ddr ./ rho) - (X.r .* X.dr .* drho ./ (rho.^2));
dddrho = (3 * X.dr .* X.ddr ./ rho) ...
    - (3 * X.r .* X.dr.^3 ./ (rho.^3)) ...
    + (X.dddr .* X.r ./ rho) ...
    - (3 * X.r.^2 .* X.dr .* X.ddr ./ (rho.^3)) ...
    + (3 * X.r.^3 .* X.dr.^3 ./ (rho.^5)); 

% compute cartesian coordinates
sintheta = sin(X.theta);
costheta = cos(X.theta);
sinphi = sin(X.phi);
cosphi = cos(X.phi);
x = rho .* sintheta .* cosphi;
y = rho .* sintheta .* sinphi;
z = X.r .* costheta;

% z-substitutions in x and y equations are now modified
zz = (rho .* costheta);
dzz = (drho .* costheta) - (X.dtheta .* rho .* sintheta);
ddzz = (ddrho .* costheta) - (X.dtheta .* drho .* sintheta) ...
    - (X.ddtheta .* rho .* sintheta) - (X.dtheta .* drho .* sintheta) ...
    - (X.dtheta.^2 .* rho .* costheta);

% TEST
Z.rho = rho;
Z.drho = drho;
Z.ddrho = ddrho;
Z.dddrho = dddrho;

% compute first derivatives (parentheses for guidence)
dx = (drho .* x ./ rho) + (X.dtheta .* zz .* cosphi) - (X.dphi .* y);
dy = (drho .* y ./ rho) + (X.dtheta .* zz .* sinphi) + (X.dphi .* x); 
dz = (X.dr .* costheta) - (X.dtheta .* X.r .* sintheta);

% compute second derivatives (parentheses for guidence)
ddx = (ddrho .* x ./ rho) - (drho.^2 .* x ./ (rho.^2)) + (drho .* dx ./ rho) ...
    + (X.ddtheta .* zz .* cosphi) + (X.dtheta .* dzz .* cosphi) ...
    - (X.dphi .* X.dtheta .* zz .* sinphi) - (X.ddphi .* y) - (X.dphi .* dy);
ddy = (ddrho .* y ./ rho) - (drho.^2 .* y ./ (rho.^2)) + (drho .* dy ./ rho) ...
    + (X.ddtheta .* zz .* sinphi) + (X.dtheta .* dzz .* sinphi) ...
    + (X.dtheta .* X.dphi .* zz .* cosphi) + (X.ddphi .* x) + (X.dphi .* dx);
ddz = (X.ddr .* costheta) - 2*(X.dtheta .* X.dr .* sintheta) ...
    - (X.ddtheta .* X.r .* sintheta) - (X.dtheta.^2 .* z);

% compute third derivatives (parentheses for guidence)
dddx = (dddrho .* x ./ rho) ...
    - 3 * drho .* ddrho .* x ./ (rho.^2) ...
    + 2 * ddrho .* dx ./ rho ...
    + 2 * drho.^3 .* x ./ (rho.^3) ...
    - 2 * drho.^2 .* dx ./ (rho.^2) ...
    + drho .* ddx ./ rho ...
    + X.dddtheta .* zz .* cosphi ...
    + 2 * X.ddtheta .* dzz .* cosphi ...
    - 2 * X.dphi .* X.ddtheta .* zz .* sinphi ...
    + X.dtheta .* ddzz .* cosphi ...
    - 2 * X.dphi .* X.dtheta .* dzz .* sinphi ...
    - X.ddphi .* X.dtheta .* zz .* sinphi ...
    - X.dphi.^2 .* X.dtheta .* zz .* cosphi ...
    - X.dddphi .* y ...
    - 2 * X.ddphi .* dy ...
    - X.dphi .* ddy;
dddy = (dddrho .* y ./ rho) - (3 * ddrho .* drho .* y ./ (rho.^2)) ...
    + (2 * ddrho .* dy ./ rho) + (2 * drho.^3 .* y ./ (rho.^3)) ...
    - (2 * drho.^2 .* dy ./ (rho.^2)) + (drho .* ddy ./ rho) ...
    + (X.dddtheta .* zz .* sinphi) + (2 * X.ddtheta .* dzz .* sinphi) ...
    + (2 * X.dphi .* X.ddtheta .* zz .* cosphi) ...
    + (X.dtheta .* ddzz .* sinphi) ...
    + (2 * X.dphi .* X.dtheta .* dzz .* cosphi) ...
    + (X.ddphi .* X.dtheta .* zz .* cosphi) ...
    - (X.dphi.^2 .* X.dtheta .* zz .* sinphi) ...
    + (X.dddphi .* x) + (2 * X.ddphi .* dx) + (X.dphi .* ddx);
dddz = (X.dddr .* costheta) - (3 * X.dtheta .* X.ddr .* sintheta) ...
    - (3 * X.ddtheta .* X.dr .* sintheta) ...
    - (2 * X.dtheta.^2 .* X.dr .* costheta) ...
    - (X.dddtheta .* X.r .* sintheta) ...
    - (3 * X.dtheta .* X.ddtheta .* z) - (X.dtheta.^2 .* dz);

% fill the output structure (clearing memory as we go, since these are big)
clear costheta sintheta cosphi sinphi;
clear rho drho ddrho dddrho;
Z.x = x; clear x;
Z.dx = dx; clear dx;
Z.ddx = ddx; clear ddx;
Z.dddx = dddx; clear dddx;
Z.y = y; clear y;
Z.dy = dy; clear dy;
Z.ddy = ddy; clear ddy;
Z.dddy = dddy; clear dddy;
Z.z = z; clear z;
Z.dz = dz; clear dz;
Z.ddz = ddz; clear ddz;
Z.dddz = dddz; clear dddz;
